---
title: "搜索旋转排序数组 II"
date: 2021-04-17 16:33:00
leetcode_id: 81
parent_id: 
    - 二分查找
    - 33
tags:
    - leetcode
category:
    - 二分查找
---

```java
class Solution {
    boolean check(int l, int r, int mid, int[] nums, int target) {
        if (nums[l] <= nums[r]) { // 已经在递增区间了，很好判断 mid 在 target 的左边还是右边。
            return nums[mid] >= target;
        } else { // 区间仍然是旋转数组，mid 和 target 的位置有六种情况，其中三种满足 mid 在 target 的右边。
            // mid 和 target 都在左上方，且 mid 在 target 的右边
            if (nums[l] <= target && target <= nums[mid]) return true;
            // mid 和 target 都在右下方，且 mid 在 target 的右边
            if (target <= nums[mid] && nums[mid] <= nums[r]) return true;
            // mid 在右下方，target 在左上方，且 mid 在 target 的右边
            if (nums[mid] <= nums[r] && nums[l] <= target) return true;
            return false;
        }
    }

    public boolean search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while (l < r) {
            int mid = l + (r - l) / 2;
            
            if (nums[mid] == target) {
                return true;
            }
            // 转化成可以 check 的问题
            while (l < r && nums[l] == nums[r]) {
                l++;
            }
            if (check(l, r, mid, nums, target)) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return nums[l] == target;
    }
}
```

```java
class Solution {
    public boolean search(int[] nums, int target) {
        return search(nums, target, 0, nums.length - 1);
    }

    public boolean search(int[] nums, int target, int i, int j) {
        if (i > j) return false;
        int l = nums[i], r = nums[j];
        while (l == r && i < j) {
            i += 1;
            l = nums[i];
        }
        // 此时要么 l != r 了，要么 i == j 了
        // 这个时候就是 33 题了
        int idx = (i + j) / 2;
        int n = nums[idx];
        if (target == n) return true;
        if (target == l) return true;
        if (target == r) return true;
        // 因为此时 n 的位置已经可以确定了，所以先讨论 n 的位置
        if (n > r) { // 如果 n 在上
            if (l < target && target < n) {
                return search(nums, target, i + 1, idx - 1);
            } else {
                return search(nums, target, idx + 1, j - 1);
            }
        } else { // 如果 n 在下
            if (n < target && target < r) { // t 在下
                return search(nums, target, idx + 1, j - 1);
            } else {
                return search(nums, target, i + 1, idx - 1);
            }
        }
    }
}
```
