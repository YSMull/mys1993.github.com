---
layout: oj
title: "LeetCode-5: Longest Palindromic Substring"
date: 2017-03-27 02:17:47
tags:
    - oj
    - leetcode
---
[原题链接](https://leetcode.com/problems/longest-palindromic-substring/#/description)

## 题目描述
求字符串的最长回文子串。

## 动归解法
之前写了两题动归的题，想练习一下动态规划，现在时间是 2017-03-27 02:18:52 ，走了很多弯路，折腾了一个小时，终于独立搞出了状态转移方程，目前dp对我来说还是挺艰难的...

```
定义s[i,j]标志着以i开头j结尾的子串是否是回文子串
s[i,j] (i <= j) = 1 if i == j
                = 1 if i == j-1 && a[i] == a[j]
                = 0 if i == j-1 && a[i] != a[j]
                = 0 if s[i+1, j-1] == 0
                = 0 if s[i+1, j-1] == 1 && a[i] != a[j]
                = 1 if s[i+1, j-1] == 1 && a[i] == a[j]
```
化简 =>
```
s[i,j] (i <= j) = 1            if i == j
                = a[i] == a[j] if i == j-1
                = s[i+1, j-1] && (a[i] == a[j])
```
## 代码

```c
string longestPalindrome(string s) {
  int dp[1000][1000];
  memset(dp, -1, 1000000 * sizeof(int));
  int maxLen = 1, maxi = 0;
  for (int i = s.length() - 1; i >= 0; i--) {
      for (int j = s.length() - 1; j >= i; j--) {
          if (i == j) {
              dp[i][j] = 1;
              continue;
          }
          if (i == j - 1 ) {
              if (dp[i][j] = (s[i] == s[j])) {
                  if (j-i+1>maxLen) {
                      maxi = i;
                      maxLen = j-i+1;
                  }
              }
              continue;
          }
          if (dp[i][j] = (dp[i+1][j-1] && (s[i] == s[j]))) {
              if (j-i+1>maxLen) {
                  maxi = i;
                  maxLen = j-i+1;
              }
          }
      }
  }
  return s.substr(maxi, maxLen);
}
```
